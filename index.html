<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Classic Space Invaders. Tom Wellborn, 2025</title>
    <meta property="og:title" content="Space Invaders Reimagined (Alpha, 2025)">
    <meta property="og:description" content="A modern rework of the classic Space Invaders. Navigate your ship, dodge lasers, and fight alien invaders in this early alpha version.">
    <meta property="og:image" content="preview.png">
    <meta property="og:url" content="https://tommiew007.github.io/SpaceInvaders/>
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Space Invaders Reimagined (Alpha, 2025)">
    <meta name="twitter:description" content="A reimagined classic in alpha. Play now!">
    <meta name="twitter:image" content="preview.png">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            background-color: black;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: white;
            position: relative;
        }
        #startMessage {
            font-family: 'Press Start 2P', sans-serif;
            font-size: 16px; /* Adjust size as needed */
            color: #00FF00;  /* Match the arcade green */
            text-align: center;
        }
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background-color: #000;
        }
        /* Overlay Styles */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            flex-direction: column;
            z-index: 2;
        }
        .hidden {
            display: none;
        }
        button {
            padding: 10px 20px;
            margin-top: 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #444;
            border: none;
            color: white;
        }
        button:hover {
            background-color: #666;
        }
        /* Explosion Animation */
        .explosion {
            position: absolute;
            border: 2px solid red;
            border-radius: 50%;
            animation: explode 0.5s forwards;
            pointer-events: none;
            z-index: 3;
        }
        @keyframes explode {
            from {
                width: 10px;
                height: 10px;
                opacity: 1;
            }
            to {
                width: 50px;
                height: 50px;
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <!-- Overlays -->
    <div id="startOverlay" class="overlay">
        <h1>Space Invaders</h1>
            <p id="startMessage">Press <strong>Spacebar</strong> to Start</p>

    </div>

    <div id="directionsOverlay" class="overlay hidden">
        <h2>Controls</h2>
        <p>←: Move Left</p>
        <p>→: Move Right</p>
        <p><strong>Ctrl</strong>: Fire</p>
        <p><strong>Spacebar</strong>: Pause/Unpause</p>
        <p><strong>H</strong>: Instructions (also pauses the game)</p>
        <p><strong>Esc</strong>: End Game</p>
        <button onclick="toggleDirections()">Close</button>
    </div>

    <!-- Sound Elements -->
    <audio id="fireSound" src="shoot.wav"></audio>
    <audio id="enemyHitSound" src="invaderkilled.wav"></audio>
    <audio id="playerHitSound" src="explosion.wav"></audio>
    <audio id="explosionSound" src="invaderkilled.wav"></audio>
    <audio id="gameOverSound" src="game-over-arcade-6435.mp3"></audio>
    <audio id="mothershipHitSound" src="arcade-ui-26-229495.mp3"></audio>
    <audio id="mothershipAppearSound" src="ufo_lowpitch.wav"></audio>
    <audio id="fireworksSound" src="explosion.wav"></audio>

    <script>
        let enemyFiringDisabled = false;
        let lastUpdateTime = Date.now();
        let lastFireTime = 0;
        const fireCooldown = 300; // Minimum 300ms between shots
        let fireworks = [];
        let isMothershipSoundPlaying = false;
        const mothershipImage = new Image();
        mothershipImage.src = 'saucer@2x.png'; // Preload mothership image
        const playerImage = new Image();
        playerImage.src = 'play@2x.png'; // Preload player image

        const retroFont = '24px "Press Start 2P"';
        const shieldImage = new Image();
        shieldImage.src = 'shield@2a.png'; // Replace with the actual path to your shield image

        const alienImages = {
            1: [new Image(), new Image()], // Alien 1
            2: [new Image(), new Image()], // Alien 2
            3: [new Image(), new Image()], // Alien 3
            4: [new Image(), new Image()], // Alien 4
            5: [new Image(), new Image()], // Alien 5
            6: [new Image(), new Image()]  // Alien 6
        };
        
        // Preload images
        alienImages[1][0].src = 'inv11@2x.png';
        alienImages[1][1].src = 'inv12@2x.png';
        alienImages[2][0].src = 'inv11@2x.png';
        alienImages[2][1].src = 'inv12@2x.png';
        alienImages[3][0].src = 'inv31@2x.png';
        alienImages[3][1].src = 'inv32@2x.png';
        alienImages[4][0].src = 'inv31@2x.png'; 
        alienImages[4][1].src = 'inv32@2x.png';
        alienImages[5][0].src = 'inv21@2x.png';
        alienImages[5][1].src = 'inv22@2x.png';
        alienImages[6][0].src = 'inv21@2x.png';
        alienImages[6][1].src = 'inv22@2x.png';

        const invaderSounds = [
            new Audio('fastinvader1.wav'),
            new Audio('fastinvader2.wav'),
            new Audio('fastinvader3.wav'),
            new Audio('fastinvader4.wav')
        ];
        let currentInvaderSound = 0; // Tracks which sound to play
        let stepDelay = 800; // Starting delay in milliseconds for step movement
        let lastStepTime = 0; // Tracks last step time

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const startOverlay = document.getElementById('startOverlay');
        const directionsOverlay = document.getElementById('directionsOverlay');

        const GAME_WIDTH = canvas.width;
        const GAME_HEIGHT = canvas.height;

        let keys = {};
        let gameState = 'start'; // 'start', 'playing', 'paused', 'countdown', 'gameover'
        let spacePressed = false;

        let playerRespawning = false; // Tracks if the player is in respawn mode
        let respawnCountdown = 3;     // Countdown timer for respawn (in seconds)
        let respawnStartTime = null;  // Tracks when the respawn countdown started

        // Sound Effects
        const fireSound = document.getElementById('fireSound');
        const enemyHitSound = document.getElementById('enemyHitSound');
        const playerHitSound = document.getElementById('playerHitSound');
        const explosionSound = document.getElementById('explosionSound');
        const gameOverSound = document.getElementById('gameOverSound');
        const mothershipHitSound = document.getElementById('mothershipHitSound');
        const mothershipAppearSound = document.getElementById('mothershipAppearSound');
        const fireworksSound = document.getElementById('fireworksSound');

        const SCALE = isMobileDevice() ? 0.5 : 1; // Reduce size by half for mobile

        // Player
        const playerWidth = 60 * SCALE;
        const playerHeight = 30 * SCALE;
         

        // Enemies
        const enemyRows = 6;
        const enemyCols = 10;
        const enemyWidth = 40 * SCALE;
        const enemyHeight = 30 * SCALE;
        const enemyPadding = 15;
        let enemies = [];
        let enemyDirection = 1; // 1: right, -1: left
        let enemySpeed = 1;
        let initialEnemyCount = enemyRows * enemyCols;

        // Enemy Bullets
        const bulletWidth = 5;
        const bulletHeight = 10;
        const bulletSpeed = 5;
        let enemyBullets = [];

        // Player Bullets
        const playerBulletSpeed = 7;

        // Shields
        const shieldWidth = 100 * SCALE;
        const shieldHeight = 50 * SCALE;
        const shieldCount = 4;
        const shieldSpacing = (GAME_WIDTH - (shieldCount * shieldWidth)) / (shieldCount + 1);
        let shields = [];

        // Explosion Effects
        let explosions = [];

        // Motherships
        let motherships = [];
        const mothershipInterval = 30000; // Every 30 seconds
        let lastMothershipTime = Date.now();

        // Game variables
        let score = 0;
        let gameOver = false;

        // Level variables
        let currentLevel = 1;
        let countdownStartTime = null;
        const countdownDuration = 3000; // 3 seconds in ms

        // Colors for each enemy row
        const rowColors = ['red', 'orange', 'yellow', 'green', 'blue'];

        // Create Fireworks
        function createFireworks() {
            fireworksSound.currentTime = 0;
            fireworksSound.play();
            for (let i = 0; i < 100; i++) {
                fireworks.push({
                    particles: Array.from({ length: 20 }).map(() => ({
                        x: Math.random() * GAME_WIDTH,
                        y: Math.random() * 200,
                        size: Math.random() * 3 + 2,
                        color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                        vx: Math.random() * 4 - 2,
                        vy: Math.random() * -4 - 2,
                        gravity: 0.05
                    })),
                    timer: Math.random() * 60 + 60
                });
            }
        }

        function simulateMothershipHit() {
            const activeMothership = motherships.find(mothership => mothership.alive);

            if (activeMothership) {
                let points = 0;

                if (activeMothership.speed === .5) {
                    // Slow mothership
                    points = 50;
                    console.log('Slow mothership destroyed! Awarded 50 points.');
                } else if (activeMothership.speed === 2.0) {
                    // Fast mothership
                    points = 200;
                    player.lives += 1; // Add a new life
                    console.log('Fast mothership destroyed! Awarded 200 points and gained an extra life.');
                }

                // Update score
                score += points;

                // Mark mothership as not alive
                activeMothership.alive = false;

                // Play hit sound
                mothershipHitSound.currentTime = 0;
                mothershipHitSound.play();

                // Create explosion effect at mothership's position
                createExplosion(
                    activeMothership.x + activeMothership.width / 2,
                    activeMothership.y + activeMothership.height / 2
                );

                console.log(`Mothership hit: awarded ${points} points.`);

                // Check win condition
                if (enemies.every(e => !e.alive)) {
                    createFireworks();
                    gameState = 'countdown';
                    countdownStartTime = Date.now();
                }
            } else {
                console.log('No active mothership to strike.');
                // Optional: Display a temporary message on the screen
            }
        }


        function togglePause() {
            if (gameState === 'playing') {
                pauseGame();
                // Pause mothership sound if playing
                if (isMothershipSoundPlaying) {
                    mothershipAppearSound.pause();
                }
            } else if (gameState === 'paused') {
                resumeGame();
                // Resume mothership sound if applicable
                if (isMothershipSoundPlaying) {
                    mothershipAppearSound.play();
                }
            }
        }
        function handleStart() {
            if (gameState === 'start') {
                startGame();
            }
        }
        // Check if the device is mobile
        function isMobileDevice() {
            return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth <= 800;
        }

        // Change start message dynamically
        const startMessage = document.getElementById('startMessage');
        if (isMobileDevice()) {
            startMessage.innerHTML = "Tap <strong>Screen</strong> to Start";
        }

        function resizeCanvas() {
            if (isMobileDevice()) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            } else {
                canvas.width = 800;
                canvas.height = 600;
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);


        function destroyAllAliens() {
            enemies.forEach(enemy => {
                if (enemy.alive) {
                    enemy.alive = false;
                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                    score += 10; // Add points for each alien destroyed
                }
            });

            adjustEnemySpeed(); // Recalculate enemy speed based on zero remaining
            enemyHitSound.currentTime = 0;
            enemyHitSound.play();

            // Trigger win condition immediately
            if (enemies.every(e => !e.alive)) {
                createFireworks();
                gameState = 'countdown';
                countdownStartTime = Date.now();
            }
        }

        function tintImage(image, color) {
            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');

            // Match image dimensions
            offCanvas.width = image.width;
            offCanvas.height = image.height;

            // Draw the base image
            offCtx.drawImage(image, 0, 0);

            // Apply tint color
            offCtx.globalCompositeOperation = 'source-atop';
            offCtx.fillStyle = color;
            offCtx.fillRect(0, 0, image.width, image.height);

            return offCanvas; // Return the tinted version
        }
        function initEnemies(level) {
            enemies = [];
            const baseY = 50 + level * 20; // Move enemies down by 20 pixels per level
            const rowHeight = enemyHeight + enemyPadding;

            for (let row = 0; row < enemyRows; row++) {
                for (let col = 0; col < enemyCols; col++) {
                    let enemyX = 60 + col * (enemyWidth + enemyPadding);
                    let enemyY = baseY + row * rowHeight;

                    const alienType = (row % 6) + 1; // Cycle through 6 types
                    enemies.push({
                        x: enemyX,
                        y: enemyY,
                        width: enemyWidth,
                        height: enemyHeight,
                        type: alienType,
                        frame: 0,
                        alive: true,
                        explosionTimer: 0
                    });
                }
            }

            enemyDirection = 1; // Reset direction
            enemySpeed = 1;     // Reset speed
            initialEnemyCount = enemyRows * enemyCols;
        }


        // Initialize Shields
        function initShields() {
            shields = [];
            for (let i = 0; i < shieldCount; i++) {
                let shieldX = shieldSpacing + i * (shieldWidth + shieldSpacing);
                let shieldY = GAME_HEIGHT - playerHeight - shieldHeight - 50;
                shields.push({
                    x: shieldX,
                    y: shieldY,
                    width: shieldWidth,
                    height: shieldHeight,
                    segments: createShieldSegments(shieldWidth, shieldHeight) // Custom layout
                });
            }

            // Initialize player after shields are set
            let middleShield = shields[Math.floor(shields.length / 2)]; // Get the middle shield
            player = {
                x: middleShield.x + middleShield.width / 2 - playerWidth / 2, // Centered under the middle shield
                y: middleShield.y + shieldHeight + 40, // 30 pixels below shield level
                width: playerWidth,
                height: playerHeight,
                speed: 200,
                color: 'green',
                bullets: [],
                lives: 3,
                isExploding: false,
                explosionTimer: 0
            };
        }

        // Create shield segments as a grid
        function createShieldSegments(width, height) {
            let segments = [];
            const topRows = 2; // Top two rows
            const bottomRows = 3; // Bottom three rows
            const topCols = 2; // 2 columns for top rows
            const bottomCols = 4; // 4 columns for bottom rows

            const segmentWidth = width / bottomCols; // Base segment width for 4 columns
            const segmentHeight = height / (topRows + bottomRows); // Divide total height into 5 rows

            // Create top rows (2x2)
            for (let r = 0; r < topRows; r++) {
                for (let c = 0; c < topCols; c++) {
                    segments.push({
                        x: (bottomCols / 2 - topCols / 2) * segmentWidth + c * segmentWidth, // Centered 2 columns
                        y: r * segmentHeight,
                        width: segmentWidth,
                        height: segmentHeight,
                        intact: true,
                    });
                }
            }

            // Create bottom rows (4x3)
            for (let r = 0; r < bottomRows; r++) {
                for (let c = 0; c < bottomCols; c++) {
                    segments.push({
                        x: c * segmentWidth, // Spread across full width
                        y: topRows * segmentHeight + r * segmentHeight, // Offset below top rows
                        width: segmentWidth,
                        height: segmentHeight,
                        intact: true,
                    });
                }
            }

            return segments;
        }


        initEnemies(currentLevel);
        initShields();

        // Event Listeners

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.code === 'KeyB') {
                destroyAllAliens(); // Feature: Destroy all aliens
                return; // Prevent further processing
            }

            if (e.code === 'KeyM') { // **Handle 'M' Key**
                simulateMothershipHit(); // Function to simulate a mothership strike
            }
            if (e.code === 'Space') {
                if (!spacePressed) {
                    spacePressed = true;
                    if (gameState === 'start') {
                        startGame();
                        return;
                    }
                    if (gameState === 'playing' || gameState === 'paused') {
                        togglePause();
                        return;
                    }
                }
            }

            if (e.code === 'KeyP') {
                resetPlayer();
            }

            if (gameState === 'playing') {
                if (e.code === 'KeyH') {
                    toggleDirections();
                }
                if (e.code === 'Escape') {
                    endGame();
                }
            }

            // Track key state
            keys[e.code] = true;
        });
        // Start game on tap for mobile
        // Start game on tap for mobile
        if (isMobileDevice()) {
            startOverlay.addEventListener('touchstart', handleStart); // Attach listener to overlay
        }

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spacePressed = false;
            }
            keys[e.code] = false;
        
            // Reset fired flag for firing keys
            if (e.code === 'ControlLeft' || e.code === 'ControlRight') {
                keys['ControlFired'] = false;
            }
        });
        function toggleDirections() {
            const directionsOverlay = document.getElementById('directionsOverlay');
            if (directionsOverlay.classList.contains('hidden')) {
                directionsOverlay.classList.remove('hidden');
                gameState = 'paused'; // Pause the game when help is shown
            } else {
                directionsOverlay.classList.add('hidden');
                gameState = 'playing'; // Resume the game when help is hidden
            }
        }

        function startGame() {
            startOverlay.classList.add('hidden');
            gameState = 'playing';
            gameLoop();
        }

        function pauseGame() {
            gameState = 'paused';
        }

        function resumeGame() {
            gameState = 'playing';
            gameLoop();
        }

        function togglePause() {
            if (gameState === 'playing') {
                pauseGame();
            } else if (gameState === 'paused') {
                resumeGame();
            }
        }

        function endGame() {
            const confirmEnd = confirm('Are you sure you want to end the game?');
            if (confirmEnd) {
                gameState = 'gameover';
                showGameOver();
            }
        }

        function showGameOver() {
            gameOverSound.play();
            alert(`Game Over!\nYour Score: ${score}`);
            document.location.reload();
        }
    if (isMobileDevice()) {
        let touchStartX = 0;

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
        });

        canvas.addEventListener('touchmove', (e) => {
            const touchX = e.touches[0].clientX;
            const deltaX = touchX - touchStartX;

            // Move the player based on swipe direction
            if (deltaX > 10) {
                player.x += player.speed; // Move right
            } else if (deltaX < -10) {
                player.x -= player.speed; // Move left
            }

            touchStartX = touchX; // Update starting point
        });

        // Tap anywhere on the screen to fire
        canvas.addEventListener('touchend', () => {
            if (player.bullets.length < 3) {
                player.bullets.push({
                    x: player.x + player.width / 2 - 2.5,
                    y: player.y,
                    width: 5,
                    height: 15,
                    color: 'yellow'
                });
                fireSound.currentTime = 0;
                fireSound.play();
            }
        });
    }

        // Game Loop
    function gameLoop() {
        const now = Date.now();
        const deltaTime = (now - lastUpdateTime) / 1000; // Time elapsed in seconds
        lastUpdateTime = now; // Update the time tracker

        if (!playerRespawning) {
            update(deltaTime); // Pass deltaTime to update logic only if not respawning
        } else {
            console.log('Skipping game loop during respawn...');
        }

        draw(); // Drawing should continue regardless of state

        if (!gameOver) {
            requestAnimationFrame(gameLoop);
        }
    }

        // Update Game State
        function update(deltaTime) {
        if (playerRespawning) {
            // Update explosions while paused
            console.log('Player is respawning, skipping update.');
            explosions.forEach((explosion, index) => {
                explosion.x += explosion.vx;
                explosion.y += explosion.vy;
                explosion.vx *= 0.98;
                explosion.vy *= 0.98;   
                explosion.size *= 0.95;
                explosion.timer--;
                if (explosion.timer <= 0 || explosion.size < 0.5) {
                    explosions.splice(index, 1);
                }
            });
        
            // Countdown Timer
            const elapsed = Date.now() - respawnStartTime;
            respawnCountdown = 3 - Math.floor(elapsed / 1000);
        
            // Respawn when countdown ends
            if (elapsed >= 3000) {
                playerRespawning = false;
                player.isExploding = false;
                player.x = GAME_WIDTH / 2 - playerWidth / 2; // Reset position
                player.y = GAME_HEIGHT - playerHeight - 40; // Keep it aligned
            }
        
            return; // Skip all other updates during countdown
        }

            if (gameState === 'countdown') {
                const elapsed = Date.now() - countdownStartTime;
            
                // Transition to next level after countdown
                if (elapsed >= countdownDuration) {
                    startNextLevel(); // Moves to the next level
                }
                return; // Exit update to prevent further processing
            }



            if (gameState !== 'playing') return;

            // Player Movement
             if (keys['ArrowLeft'] && player.x > 0) {
                player.x -= player.speed * deltaTime; // Scaled appropriately
            }
            if (keys['ArrowRight'] && player.x + playerWidth < GAME_WIDTH) {
                player.x += player.speed * deltaTime; // Scaled appropriately
            }

            // Fire Player Bullet
            // Limit the player to 3 bullets at a time
            if (
                (keys['ControlLeft'] || keys['ControlRight']) && // Fire button pressed
                !keys['ControlFired'] &&                        // Not already firing
                player.bullets.length < 3                       // Bullet count limit
            ) {
                player.bullets.push({
                    x: player.x + player.width / 2 - 2.5, // Centered bullet
                    y: player.y,
                    width: 5,
                    height: 15,
                    color: 'blue'
                });
                fireSound.currentTime = 0;
                fireSound.play();
                keys['ControlFired'] = true; // Prevent rapid fire
            }


            // Update Player Bullets
            player.bullets.forEach((bullet, index) => {
                bullet.y -= playerBulletSpeed * deltaTime * 60;
                // Remove bullet if it goes off screen
                if (bullet.y + bullet.height < 0) {
                    player.bullets.splice(index, 1);
                } else {
                    let hit = false;

                    // Check collision with enemies
                    enemies.forEach((enemy, eIndex) => {
                        if (enemy.alive && isColliding(bullet, enemy)) {
                            enemy.alive = false;
                            enemyHitSound.currentTime = 0;
                            enemyHitSound.play();
                            player.bullets.splice(index, 1);
                            score += 10;
                                createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                            // Adjust enemy speed based on remaining enemies
                            adjustEnemySpeed();
                            hit = true;
                        }
                    });

                    if (hit) return; // Bullet already handled

                    // Check collision with shields
                    shields.forEach((shield) => {
                        shield.segments.forEach((segment) => {
                            if (segment.intact && isColliding(bullet, {
                                x: shield.x + segment.x,
                                y: shield.y + segment.y,
                                width: segment.width,
                                height: segment.height
                            })) {
                                segment.intact = false;
                                player.bullets.splice(index, 1);
                                hit = true;
                            }
                        });
                    });

                    if (hit) return; // Bullet already handled

                    // Check collision with motherships
    // Check collision with motherships
    motherships.forEach((mothership, mIndex) => {
        if (mothership.alive && isColliding(bullet, mothership)) {
            let points = 0;
            
            if (mothership.speed === .5) {
                // Slow mothership
                points = 50;
                console.log('Slow mothership destroyed!  ');
            } else if (mothership.speed === 2.0) {
                // Fast mothership
                points = 200;
                player.lives += 1; // Add a new life
                console.log('Fast mothership destroyed! Player gains an extra life.');
            }
            
            score += points;
            mothership.alive = false;
            mothershipHitSound.currentTime = 0;
            mothershipHitSound.play();
            player.bullets.splice(index, 1);
            createExplosion(mothership.x + mothership.width / 2, mothership.y + mothership.height / 2);
            hit = true;
        }
    });

                }
            });

            // Calculate enemy speed based on the number of remaining enemies
            enemySpeed = calculateEnemySpeed();

            // Move enemies in 'step' fashion
    const now = Date.now();
    if (now - lastStepTime > stepDelay) {
        let shouldMoveDown = false;

        enemies.forEach(enemy => {
            if (enemy.alive) {
                enemy.x += (enemyWidth / 2) * enemyDirection; // Half-step horizontal movement
                enemy.frame = 1 - enemy.frame; // Toggle frame for animation

            if (enemy.x + enemy.width >= GAME_WIDTH - enemyPadding || enemy.x <= enemyPadding) {
                shouldMoveDown = true;
            }
            }
        });

        if (shouldMoveDown) {
            enemyDirection *= -1;
            enemies.forEach(enemy => {
                if (enemy.alive) {
                    enemy.y += enemyHeight / 2; // Half-step vertical movement
                }
            });
        }

        // Play step sound and cycle
        invaderSounds[currentInvaderSound].currentTime = 0;
        invaderSounds[currentInvaderSound].play();
        currentInvaderSound = (currentInvaderSound + 1) % invaderSounds.length;

        lastStepTime = now;
        adjustStepSpeed(); // Update speed based on enemies
    }

            // Check collision between enemies and shields
            enemies.forEach(enemy => {
                if (enemy.alive) {
                    shields.forEach(shield => {
                        shield.segments.forEach(segment => {
                            if (segment.intact && isColliding(enemy, {
                                x: shield.x + segment.x,
                                y: shield.y + segment.y,
                                width: segment.width,
                                height: segment.height
                            })) {
                                segment.intact = false;
                            }
                        });
                    });
                }
            });

    // Fire Enemy Bullets
    if (!enemyFiringDisabled && Math.random() < 0.005) { // Adjusted firing frequency
        const aliveEnemies = enemies.filter(e => e.alive);
        if (aliveEnemies.length > 0) {
            const shooter = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
            enemyBullets.push({
                x: shooter.x + shooter.width / 2 - bulletWidth / 2,
                y: shooter.y + shooter.height,
                width: bulletWidth,
                height: bulletHeight,
                color: 'red'
            });
        }
    }

            // Update Enemy Bullets
            enemyBullets.forEach((bullet, index) => {
                  bullet.y += bulletSpeed * deltaTime * 60; // Ensure this multiplication is intentional
                // Remove bullet if it goes off screen
                if (bullet.y > GAME_HEIGHT) {
                    enemyBullets.splice(index, 1);
                } else {
                    let hit = false;

                    // Check collision with shields
                    shields.forEach((shield) => {
                        shield.segments.forEach((segment) => {
                            if (segment.intact && isColliding(bullet, {
                                x: shield.x + segment.x,
                                y: shield.y + segment.y,
                                width: segment.width,
                                height: segment.height
                            })) {
                                segment.intact = false;
                                enemyBullets.splice(index, 1);
                                hit = true;
                            }
                        });
                    });

                    if (hit) return; // Bullet already handled

                    // Check collision with player
                    if (isColliding(bullet, player) && !player.isExploding) {
                        enemyBullets.splice(index, 1);
                        playerHitSound.currentTime = 0;
                        playerHitSound.play();
                        createExplosion(player.x + player.width / 2, player.y + player.height / 2);
                         
                        if (player.lives > 0) {
                            resetPlayer();
                        } else {
                            gameOver = true;
                            showGameOver();
                        }
                    }
                }
            });



    motherships.forEach((mothership, mIndex) => {
        if (mothership.alive) {
            mothership.x += mothership.speed;

            // Stop sound and remove mothership if it leaves the screen
            if ((mothership.direction === 'right' && mothership.x > GAME_WIDTH) ||
                (mothership.direction === 'left' && mothership.x + mothership.width < 0)) {
                mothership.alive = false;
                mothership.sound.pause();
                mothership.sound.currentTime = 0; // Reset sound
            }
        }
    });

    // Remove dead motherships and stop their sounds
    motherships = motherships.filter(mothership => {
        if (!mothership.alive) {
            mothership.sound.pause();
            mothership.sound.currentTime = 0;
            return false; // Remove from array
        }
        return true;
    });

            // Spawn Motherships
            if (Date.now() - lastMothershipTime > mothershipInterval) {
                spawnMothership();
                lastMothershipTime = Date.now();
            }

    // Update Explosions
    explosions.forEach((explosion, index) => {
        explosion.x += explosion.vx; // Move horizontally
        explosion.y += explosion.vy; // Move vertically

        // Apply slight slowdown effect (friction)
        explosion.vx *= 0.98;
        explosion.vy *= 0.98;

        // Gradually shrink particle size
        explosion.size *= 0.95;

        // Reduce timer
        explosion.timer--;

        // Remove particles when their timer expires or they become too small
        if (explosion.timer <= 0 || explosion.size < 0.5) {
            explosions.splice(index, 1);
        }
    });


            // Update Fireworks
            fireworks.forEach((firework, index) => {
                firework.timer--;
                firework.particles.forEach((particle) => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += particle.gravity;
                });
                if (firework.timer <= 0) {
                    fireworks.splice(index, 1);
                }
            });

            // Check Win Condition
            if (enemies.every(e => !e.alive)) {
                createFireworks();
                gameState = 'countdown';
                countdownStartTime = Date.now();
            }

            // Check if any enemy has reached the player's level
            enemies.forEach(enemy => {
                if (enemy.alive && enemy.y + enemy.height >= player.y) {
                    gameOver = true;
                    showGameOver();
                }
            });
        }
    function adjustStepSpeed() {
        const remainingEnemies = enemies.filter(enemy => enemy.alive).length;
        const totalEnemies = enemyRows * enemyCols;

        if (remainingEnemies === 1) {
            stepDelay = 200 / 3; // 200% faster for the last enemy
        } else if (remainingEnemies <= totalEnemies / 4) {
            stepDelay = 300 * 0.8; // Speed 3 increased by 20%
        } else if (remainingEnemies <= totalEnemies / 2) {
            stepDelay = 500; // Speed 2 unchanged
        } else if (remainingEnemies <= (3 * totalEnemies) / 4) {
            stepDelay = 650; // Speed 1 unchanged
        } else {
            stepDelay = 800; // Starting speed
        }
    }

    function drawEnemies() {
        enemies.forEach(enemy => {
            if (enemy.alive) {
                const img = alienImages[enemy.type][enemy.frame]; // Select image by type and frame
                
                // Ensure the image is loaded before drawing
                if (img.complete && img.naturalHeight !== 0) {
                    ctx.drawImage(img, enemy.x, enemy.y, enemy.width, enemy.height); // Draw alien image
                } else {
                    // Fallback placeholder if image is not loaded
                    ctx.fillStyle = 'white';
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                }
            }
        });
    }
    function drawExplosions() {
        explosions.forEach(explosion => {
            ctx.fillStyle = explosion.color; // Random color per particle
            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, explosion.size, 0, Math.PI * 2);
            ctx.fill();
        });
    }
            
            
    function drawMotherships() {
        motherships.forEach(mothership => {
            if (mothership.alive) {
                if (mothershipImage.complete && mothershipImage.naturalHeight !== 0) {
                    // Draw mothership using the image
                    ctx.drawImage(mothershipImage, mothership.x, mothership.y, mothership.width, mothership.height);
                } else {
                    // Fallback placeholder if image isn't loaded
                    ctx.fillStyle = 'purple';
                    ctx.fillRect(mothership.x, mothership.y, mothership.width, mothership.height);
                }
            }
        });
    }

        function drawPlayer() {
        if (!player.isExploding) {
            if (playerImage.complete && playerImage.naturalHeight !== 0) {
                ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
            } else {
                // Fallback placeholder if the image hasn't loaded
                ctx.fillStyle = 'green';
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }
        }
    }


    function drawShields() {
        shields.forEach(shield => {
            shield.segments.forEach(segment => {
                if (segment.intact) {
                    // Draw the shield segment using the shieldImage
                    if (shieldImage.complete && shieldImage.naturalHeight !== 0) {
                        ctx.drawImage(
                            shieldImage, // Source image
                            shield.x + segment.x, // X position
                            shield.y + segment.y, // Y position
                            segment.width, // Width
                            segment.height // Height
                        );
                    } else {
                        // Fallback if image isn't loaded
                        ctx.fillStyle = 'green';
                        ctx.fillRect(shield.x + segment.x, shield.y + segment.y, segment.width, segment.height);
                    }
                }
                // **Remove the else block to prevent clearing shield segments programmatically**
                // Else: Do not draw anything, allowing invaders to pass through
            });
        });
    }
    function drawFireworks() {
        fireworks.forEach(firework => {
            firework.particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
        });
    }

        // Draw Game State
    function draw() {
        // Clear fireworks before drawing new frames
        fireworks = fireworks.filter(firework => firework.timer > 0);
        // Clear Canvas
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        if (playerRespawning) {
            // Apply grayscale filter (already handled in resetPlayer())
            // No need to dim the screen manually

            // Draw explosions during respawn
            explosions.forEach(explosion => {
                ctx.fillStyle = explosion.color;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Display countdown text
            ctx.font = '14px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.fillText(`Respawning in ${respawnCountdown}`, GAME_WIDTH / 2, GAME_HEIGHT / 2);

            // **Remove the return statement to continue drawing the rest of the game**
            // return; // Comment out or remove this line
        }

        if (gameState === 'start') {
            // Dim screen handled by overlay
            return;
        }

        if (gameState === 'countdown') {
            // Draw countdown overlay
            const now = Date.now();
            const elapsed = now - countdownStartTime;
            let remaining = 3 - Math.floor(elapsed / 1000);
            if (remaining < 0) remaining = 0; // Prevent negative numbers

            // Dim the background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(GAME_WIDTH / 2 - 150, GAME_HEIGHT / 2 - 75, 300, 150);

            // Draw game elements in the background
            drawShields();
            drawEnemies();
            drawPlayer();
            drawMotherships();
            drawExplosions();

            // Draw Countdown Text
            ctx.fillStyle = 'white';
            ctx.font = isMobileDevice() ? '30px Arial' : '36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Level ${currentLevel + 1} starting in ${remaining}`, GAME_WIDTH / 2, GAME_HEIGHT / 2);
            ctx.textAlign = 'left';

            return; // Skip the rest of the draw cycle during countdown
        }

        // **Continue drawing all game elements regardless of respawn state**
        // Draw Player
        drawPlayer();

        // Draw Player Bullets
        player.bullets.forEach(bullet => {
            ctx.fillStyle = bullet.color;
            ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        });

        // Draw Enemies
        drawEnemies();

        // Draw Enemy Bullets
        enemyBullets.forEach(bullet => {
            ctx.fillStyle = bullet.color;
            ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        });

        drawShields();          // Draw shields first
        drawPlayer();           // Then player
      //  drawPlayerBullets();    // Then player bullets
        drawEnemies();          // Then enemies
      //  drawEnemyBullets();     // Then enemy bullets
        drawMotherships();      // Then motherships
        drawExplosions();       // Then explosions
        drawFireworks();        // Then fireworks

        // Draw Score and Lives
        const padding = 20; // Space from the edges
        const textHeight = 30; // Height for text placement
        const retroColor = '#00FF00'; // Classic arcade green color

        ctx.fillStyle = retroColor;
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'left';
        ctx.fillText(`SCORE: ${score}`, padding, textHeight);

        // Draw Player Lives (Top Right)
        ctx.textAlign = 'right';
        ctx.fillText(`LIVES: ${player.lives}/3`, GAME_WIDTH - padding, textHeight);
        ctx.textAlign = 'left';

        // If Paused
        if (gameState === 'paused') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(GAME_WIDTH / 2 - 150, GAME_HEIGHT / 2 - 75, 300, 150);
            ctx.fillStyle = 'white';
            ctx.font = isMobileDevice() ? '24px Arial' : '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Paused', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20);
            ctx.fillText('Press Spacebar to Resume', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 20);
            ctx.textAlign = 'left';
        }
    }


        // Collision Detection
        function isColliding(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

    // Create Scatter Explosion Effect
    function createExplosion(x, y) {
        const particleCount = 50; // Increase particle count for a larger scatter
        const explosionSpeed = 4; // Increase speed for more spread
        const explosionSize = 5; // Larger initial size for particles

        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2; // Random angle (0 to 360 degrees)
            const speed = Math.random() * explosionSpeed + 1; // Random speed between 1 and explosionSpeed
            explosions.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed, // Horizontal velocity
                vy: Math.sin(angle) * speed, // Vertical velocity
                size: Math.random() * explosionSize + 2, // Random size between 2 and explosionSize
                color: `hsl(${Math.random() * 360}, 100%, 50%)`, // Random colors for vibrant effect
                timer: Math.random() * 40 + 30 // Lifespan between 30 and 70 frames
            });
        }

        explosionSound.currentTime = 0;
        explosionSound.play();
    }


        // Reset Player After Hit
 
    function resetPlayer() {
        if (playerRespawning || player.isExploding) {
            console.log('Player is already respawning or exploding.');
            return;
        }

        console.log('Player hit! Starting respawn sequence.');
        player.isExploding = true;
        playerRespawning = true;

        // Decrement lives
        if (player.lives > 0) {
            player.lives--;
            console.log(`Lives decremented: ${player.lives}`);
        }

        // Check for Game Over
        if (player.lives <= 0) {
            console.log('No lives left. Game Over!');
            showGameOver();
            return;
        }

        // Trigger explosion
        createExplosion(player.x + player.width / 2, player.y + player.height / 2);
        explosionSound.currentTime = 0;
        explosionSound.play();

        // Disable enemy firing and clear existing enemy bullets
        enemyFiringDisabled = true;
        enemyBullets = [];

        // Duration of the explosion animation (e.g., 0.5 seconds)
        const explosionDuration = 500; // in milliseconds
        const grayscaleDuration = 1000; // 1 second

        setTimeout(() => {
            console.log('Applying grayscale filter.');
            canvas.style.filter = 'grayscale(100%)'; // Apply black and white filter

            // Duration of the grayscale effect
            setTimeout(() => {
                // Start the 3-second countdown before resuming the game
                respawnCountdown = 3;
                respawnStartTime = Date.now();
                const countdownInterval = setInterval(() => {
                    const elapsed = Date.now() - respawnStartTime;
                    const remaining = 3 - Math.floor(elapsed / 1000);
                    if (remaining >= 0) {
                        respawnCountdown = remaining;
                    }
                    if (elapsed >= 3000) {
                        clearInterval(countdownInterval);
                        console.log('Resuming gameplay.');

                        // Reset player position
                        player.x = GAME_WIDTH / 2 - playerWidth / 2;
                        player.y = GAME_HEIGHT - playerHeight - 40;

                        // Remove respawning flags
                        player.isExploding = false;
                        playerRespawning = false;

                        // Remove grayscale filter
                        console.log('Removing grayscale filter.');
                        canvas.style.filter = 'none'; // Revert to color

                        // Re-enable enemy firing after 2 seconds
                        setTimeout(() => {
                            enemyFiringDisabled = false;
                            console.log('Enemy firing re-enabled.');
                        }, 2000); // 2000 milliseconds = 2 seconds
                    }
                }, 1000); // Changed from 1 ms to 1000 ms

            }, grayscaleDuration);

        }, explosionDuration);

        // **Remove the immediate removal of the grayscale filter**
        // console.log('Removing grayscale filter.');
        // canvas.style.filter = 'none'; // Revert to color
    }


        // Calculate Enemy Speed Based on the Number of Remaining Enemies
    // Calculate Enemy Speed Based on the Number of Remaining Enemies
    function calculateEnemySpeed() {
        const remainingEnemies = enemies.filter(enemy => enemy.alive).length;
        if (remainingEnemies === 0) return 1; // Default speed when no enemies

        // Calculate speed based on remaining enemies
        // When remainingEnemies = initialEnemyCount => speed = 1
        // When remainingEnemies = 1 => speed = 8
        let speed = 1 + (7 * (initialEnemyCount - remainingEnemies)) / (initialEnemyCount - 1);
        speed = Math.min(speed, 8); // Ensure speed does not exceed 8
        return speed;
    }

        // Adjust Enemy Speed Based on the Number of Remaining Enemies
        function adjustEnemySpeed() {
            enemySpeed = calculateEnemySpeed();
        }

        // Spawn Mothership
    function spawnMothership() {
        // Check if a mothership is already active
        if (motherships.some(mothership => mothership.alive)) {
            console.log('Mothership already active. Not spawning a new one.');
            return;
        }

        const direction = Math.random() < 0.5 ? 'right' : 'left';
        let speed, sound;

        // 80% chance for slow, 20% chance for fast mothership
        if (Math.random() < 0.8) {
            speed = .5; // Slow speed
            sound = "ufo_lowpitch.wav";
        } else {
            speed = 2.0; // Fast speed
            sound = "ufo_highpitch.wav";
        }

        const mothership = {
            x: direction === 'right' ? -80 : GAME_WIDTH,
            y: 30,
            width: 80,
            height: 20,
            speed: speed * (direction === 'right' ? 1 : -1),
            direction: direction,
            alive: true,
            points: speed === 1.0 ? 50 : 200, // Adjust points based on speed
            sound: new Audio(sound), // Assign the sound for this mothership
        };

        mothership.sound.loop = true; // Enable looping
        mothership.sound.play(); // Start playing the sound

        motherships.push(mothership);
        console.log(`Spawned a ${speed === .5 ? 'slow' : 'fast'} mothership moving ${direction}.`);
    }

        // Start Next Level
    function startNextLevel() {
        currentLevel++; 
        stepDelay = 800; // Reset step delay to starting value
        initEnemies(currentLevel); 
        resetShields(); 
        fireworks = []; 
        adjustStepSpeed(); 
        gameState = 'playing'; 
        requestAnimationFrame(gameLoop); 
    }

        // Reset Shields to full integrity
        function resetShields() {
            shields.forEach(shield => {
                shield.segments.forEach(segment => {
                    segment.intact = true;
                });
            });
        }

        // Initialize Game Loop and Draw Loop
        gameLoop();
    </script>
<a href="https://linktr.ee/tomwellborn3" target="_blank" 
   style="position: absolute; bottom: 10px; left: 10px; color: gray; font-size: 12px; text-decoration: none;">
   Tom Wellborn, 2025, <br>Version 1.5 Alpha
</a>
</body>
</html>
