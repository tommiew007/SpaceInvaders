<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Classic Space Invaders. Tom Wellborn, 2025</title>
    <meta property="og:title" content="Space Invaders Reimagined (Alpha, 2025)">
    <meta property="og:description" content="A modern rework of the classic Space Invaders. Navigate your ship, dodge lasers, and fight alien invaders in this early alpha version.">
    <meta property="og:image" content="preview.png">
    <meta property="og:url" content="https://tommiew007.github.io/SpaceInvaders/" />
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Space Invaders Reimagined (Alpha, 2025)">
    <meta name="twitter:description" content="A reimagined classic in alpha. Play now!">
    <meta name="twitter:image" content="preview.png">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <!-- Rest of your head content -->
</head>

    <style>
        body {
            margin: 0;
            background-color: black;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: white;
            position: relative;
        }
        #startMessage {
            font-family: 'Press Start 2P', sans-serif;
            font-size: 16px; /* Adjust size as needed */
            color: #00FF00;  /* Match the arcade green */
            text-align: center;
        }
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background-color: #000;
        }
        /* Overlay Styles */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            flex-direction: column;
            z-index: 2;
        }
        .hidden {
            display: none;
        }
        button {
            padding: 10px 20px;
            margin-top: 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #444;
            border: none;
            color: white;
        }
        button:hover {
            background-color: #666;
        }
        /* Explosion Animation */
        .explosion {
            position: absolute;
            border: 2px solid red;
            border-radius: 50%;
            animation: explode 0.5s forwards;
            pointer-events: none;
            z-index: 3;
        }
        @keyframes explode {
            from {
                width: 10px;
                height: 10px;
                opacity: 1;
            }
            to {
                width: 50px;
                height: 50px;
                opacity: 0;
            }
        }
		#gameOverOverlay {
			z-index: 3; /* Ensure it's above other overlays */
			background-color: rgba(0, 0, 0, 0.85);
		}
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <!-- Overlays -->
	<div id="gameOverOverlay" class="overlay hidden">
		<h1>GAME OVER</h1>
		<p>Your Score: <span id="finalScore">0</span></p>
		<button onclick="restartGame()">Restart</button>
	</div>    <div id="startOverlay" class="overlay">
        <h1>Space Invaders</h1>
            <p id="startMessage">Press <strong>Spacebar</strong> to Start</p>

    </div>

    <div id="directionsOverlay" class="overlay hidden">
        <h2>Controls</h2>
        <p>←: Move Left</p>
        <p>→: Move Right</p>
        <p><strong>Ctrl</strong>: Fire</p>
        <p><strong>Spacebar</strong>: Pause/Unpause</p>
        <p><strong>H</strong>: Instructions (also pauses the game)</p>
        <p><strong>Esc</strong>: End Game</p>
        <button onclick="toggleDirections()">Close</button>
    </div>

    <!-- Sound Elements -->
    <audio id="fireSound" src="shoot.wav"></audio>
    <audio id="enemyHitSound" src="invaderkilled.wav"></audio>
    <audio id="playerHitSound" src="explosion.wav"></audio>
    <audio id="explosionSound" src="invaderkilled.wav"></audio>
    <audio id="gameOverSound" src="game-over-arcade-6435.mp3"></audio>
    <audio id="mothershipHitSound" src="arcade-ui-26-229495.mp3"></audio>
    <audio id="mothershipAppearSound" src="ufo_lowpitch.wav"></audio>
    <audio id="fireworksSound" src="explosion.wav"></audio>

    <script>
        let enemyFiringDisabled = false;
        let lastUpdateTime = Date.now();
        let lastFireTime = 0;
        const fireCooldown = 300; // Minimum 300ms between shots
        let fireworks = [];
        let isMothershipSoundPlaying = false;
        const mothershipImage = new Image();
        mothershipImage.src = 'saucer@2x.png'; // Preload mothership image
        const playerImage = new Image();
        playerImage.src = 'play@2x.gif'; // Preload player image

        const retroFont = '24px "Press Start 2P"';
        const shieldImage = new Image();
        shieldImage.src = 'shield@2a.png'; // Replace with the actual path to your shield image

		// Preload mothership sounds
		const mothershipSlowSound = new Audio('ufo_lowpitch.wav');
		mothershipSlowSound.loop = true; // Enable looping

		const mothershipFastSound = new Audio('ufo_highpitch.wav');
		mothershipFastSound.loop = true; // Enable looping

		// Define mothership types with fixed attributes
		const MOTHERSHIP_TYPES = {
			SLOW: {
				type: 'slow',
				speed: 1.0, // Units per frame
				points: 50,
				sound: 'ufo_lowpitch.wav'
			},
			FAST: {
				type: 'fast',
				speed: 2.0, // Units per frame
				points: 200,
				sound: 'ufo_highpitch.wav'
			}
		};

        const alienImages = {
            1: [new Image(), new Image()], // Alien 1
            2: [new Image(), new Image()], // Alien 2
            3: [new Image(), new Image()], // Alien 3
            4: [new Image(), new Image()], // Alien 4
            5: [new Image(), new Image()], // Alien 5
            6: [new Image(), new Image()]  // Alien 6
        };
        
        // Preload images
        alienImages[1][0].src = 'inv11@2x.png';
        alienImages[1][1].src = 'inv12@2x.png';
        alienImages[2][0].src = 'inv11@2x.png';
        alienImages[2][1].src = 'inv12@2x.png';
        alienImages[3][0].src = 'inv31@2x.png';
        alienImages[3][1].src = 'inv32@2x.png';
        alienImages[4][0].src = 'inv31@2x.png'; 
        alienImages[4][1].src = 'inv32@2x.png';
        alienImages[5][0].src = 'inv21@2x.png';
        alienImages[5][1].src = 'inv22@2x.png';
        alienImages[6][0].src = 'inv21@2x.png';
        alienImages[6][1].src = 'inv22@2x.png';

        const invaderSounds = [
            new Audio('fastinvader1.wav'),
            new Audio('fastinvader2.wav'),
            new Audio('fastinvader3.wav'),
            new Audio('fastinvader4.wav')
        ];
        let currentInvaderSound = 0; // Tracks which sound to play
        let stepDelay = 800; // Starting delay in milliseconds for step movement
        let lastStepTime = 0; // Tracks last step time

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const startOverlay = document.getElementById('startOverlay');
        const directionsOverlay = document.getElementById('directionsOverlay');

        const GAME_WIDTH = canvas.width;
        const GAME_HEIGHT = canvas.height;

        let keys = {};
        let gameState = 'start'; // 'start', 'playing', 'paused', 'countdown', 'gameover'
        let spacePressed = false;

        let playerRespawning = false; // Tracks if the player is in respawn mode
        let respawnCountdown = 3;     // Countdown timer for respawn (in seconds)
        let respawnStartTime = null;  // Tracks when the respawn countdown started

        // Sound Effects
        const fireSound = document.getElementById('fireSound');
        const enemyHitSound = document.getElementById('enemyHitSound');
        const playerHitSound = document.getElementById('playerHitSound');
        const explosionSound = document.getElementById('explosionSound');
        const gameOverSound = document.getElementById('gameOverSound');
        const mothershipHitSound = document.getElementById('mothershipHitSound');
        const mothershipAppearSound = document.getElementById('mothershipAppearSound');
        const fireworksSound = document.getElementById('fireworksSound');

        const SCALE = isMobileDevice() ? 0.5 : 1; // Reduce size by half for mobile

        // Player
        const playerWidth = 60 * SCALE;
        const playerHeight = 30 * SCALE;
         

        // Enemies
        const enemyRows = 6;
        const enemyCols = 10;
        const enemyWidth = 40 * SCALE;
        const enemyHeight = 30 * SCALE;
        const enemyPadding = 15;
        let enemies = [];
        let enemyDirection = 1; // 1: right, -1: left
        let enemySpeed = 1;
        let initialEnemyCount = enemyRows * enemyCols;

        // Enemy Bullets
        const bulletWidth = 5;
        const bulletHeight = 10;
        const bulletSpeed = 5;
        let enemyBullets = [];

        // Player Bullets
        const playerBulletSpeed = 7;

        // Shields
        const shieldWidth = 100 * SCALE;
        const shieldHeight = 50 * SCALE;
        const shieldCount = 4;
        const shieldSpacing = (GAME_WIDTH - (shieldCount * shieldWidth)) / (shieldCount + 1);
        let shields = [];

        // Explosion Effects
        let explosions = [];

        // Motherships
        let motherships = [];
        const mothershipInterval = 30000; // Every 30 seconds
        let lastMothershipTime = Date.now();

        // Game variables
        let score = 0;
        let gameOver = false;

        // Level variables
        let currentLevel = 1;
        let countdownStartTime = null;
        const countdownDuration = 3000; // 3 seconds in ms

        // Colors for each enemy row
        const rowColors = ['red', 'orange', 'yellow', 'green', 'blue'];

		// Example: Destroy mothership when hit or out of bounds

// Ensure the sound loops by replaying it when it ends
//mothership.sound.addEventListener('ended', () => {
//    if (mothership.alive) {
//        mothership.sound.currentTime = 0;
//        mothership.sound.play();
//    }
//});


		function destroyMothership(mothership) {
			mothership.alive = false;
			mothership.sound.pause(); // Pause the sound
			mothership.sound.currentTime = 0; // Reset to start
			console.log(`Destroyed a ${mothership.type} mothership.`);
		}

        // Create Fireworks
		function restartGame() {
			// Reset game variables
			score = 0;
			currentLevel = 1;
			gameOver = false;
			
			// Reset canvas filter
			canvas.style.filter = 'none';
			
			// Hide the Game Over overlay
			document.getElementById('gameOverOverlay').classList.add('hidden');
			
			// Re-initialize enemies, shields, etc.
			initEnemies(currentLevel);
			resetShields();
			
			// Reset player
			player.x = GAME_WIDTH / 2 - playerWidth / 2;
			player.y = GAME_HEIGHT - playerHeight - 40;
			player.lives = 3;
			
			// Reset other game elements as needed
			enemyBullets = [];
			fireworks = [];
			explosions = [];
			motherships = [];
			
			// Start the game loop
			gameState = 'playing';
			gameLoop();
		}

        function createFireworks() {
            fireworksSound.currentTime = 0;
            fireworksSound.play();
            for (let i = 0; i < 100; i++) {
                fireworks.push({
                    particles: Array.from({ length: 20 }).map(() => ({
                        x: Math.random() * GAME_WIDTH,
                        y: Math.random() * 200,
                        size: Math.random() * 3 + 2,
                        color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                        vx: Math.random() * 4 - 2,
                        vy: Math.random() * -4 - 2,
                        gravity: 0.05
                    })),
                    timer: Math.random() * 60 + 60
                });
            }
        }

function simulateMothershipHit() {
    const activeMothership = motherships.find(mothership => mothership.alive);

    if (activeMothership) {
        let points = activeMothership.points;

        // Grant a new life if the mothership is fast
        if (activeMothership.type === 'fast') {
            player.lives += 1; // Add a new life
            console.log('Fast mothership destroyed! Player gains an extra life.');
        } else {
            console.log('Slow mothership destroyed! Awarded 50 points.');
        }

        // Update score
        score += points;

        // Mark mothership as not alive
        activeMothership.alive = false;

        // Play hit sound
        mothershipHitSound.currentTime = 0;
        mothershipHitSound.play();

        // Create explosion effect at mothership's position
        createExplosion(
            activeMothership.x + activeMothership.width / 2,
            activeMothership.y + activeMothership.height / 2
        );

        console.log(`Mothership hit: awarded ${points} points.`);

        // Check win condition
        if (enemies.every(e => !e.alive)) {
            createFireworks();
            gameState = 'countdown';
            countdownStartTime = Date.now();
        }
    } else {
        console.log('No active mothership to strike.');
        // Optional: Display a temporary message on the screen
    }
}


        function togglePause() {
            if (gameState === 'playing') {
                pauseGame();
                // Pause mothership sound if playing
                if (isMothershipSoundPlaying) {
                    mothershipAppearSound.pause();
                }
            } else if (gameState === 'paused') {
                resumeGame();
                // Resume mothership sound if applicable
                if (isMothershipSoundPlaying) {
                    mothershipAppearSound.play();
                }
            }
        }
        function handleStart() {
            if (gameState === 'start') {
                startGame();
            }
        }
        // Check if the device is mobile
        function isMobileDevice() {
            return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth <= 800;
        }

        // Change start message dynamically
        const startMessage = document.getElementById('startMessage');
        if (isMobileDevice()) {
            startMessage.innerHTML = "Tap <strong>Screen</strong> to Start";
        }

        function resizeCanvas() {
            if (isMobileDevice()) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            } else {
                canvas.width = 800;
                canvas.height = 600;
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);


        function destroyAllAliens() {
            enemies.forEach(enemy => {
                if (enemy.alive) {
                    enemy.alive = false;
                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                    score += 10; // Add points for each alien destroyed
                }
            });

            adjustEnemySpeed(); // Recalculate enemy speed based on zero remaining
            enemyHitSound.currentTime = 0;
            enemyHitSound.play();

            // Trigger win condition immediately
            if (enemies.every(e => !e.alive)) {
                createFireworks();
                gameState = 'countdown';
                countdownStartTime = Date.now();
            }
        }

        function tintImage(image, color) {
            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');

            // Match image dimensions
            offCanvas.width = image.width;
            offCanvas.height = image.height;

            // Draw the base image
            offCtx.drawImage(image, 0, 0);

            // Apply tint color
            offCtx.globalCompositeOperation = 'source-atop';
            offCtx.fillStyle = color;
            offCtx.fillRect(0, 0, image.width, image.height);

            return offCanvas; // Return the tinted version
        }
        function initEnemies(level) {
            enemies = [];
            const baseY = 50 + level * 20; // Move enemies down by 20 pixels per level
            const rowHeight = enemyHeight + enemyPadding;

            for (let row = 0; row < enemyRows; row++) {
                for (let col = 0; col < enemyCols; col++) {
                    let enemyX = 60 + col * (enemyWidth + enemyPadding);
                    let enemyY = baseY + row * rowHeight;

                    const alienType = (row % 6) + 1; // Cycle through 6 types
                    enemies.push({
                        x: enemyX,
                        y: enemyY,
                        width: enemyWidth,
                        height: enemyHeight,
                        type: alienType,
                        frame: 0,
                        alive: true,
                        explosionTimer: 0
                    });
                }
            }

            enemyDirection = 1; // Reset direction
            enemySpeed = 1;     // Reset speed
            initialEnemyCount = enemyRows * enemyCols;
        }


        // Initialize Shields
        function initShields() {
            shields = [];
            for (let i = 0; i < shieldCount; i++) {
                let shieldX = shieldSpacing + i * (shieldWidth + shieldSpacing);
                let shieldY = GAME_HEIGHT - playerHeight - shieldHeight - 50;
                shields.push({
                    x: shieldX,
                    y: shieldY,
                    width: shieldWidth,
                    height: shieldHeight,
                    segments: createShieldSegments(shieldWidth, shieldHeight) // Custom layout
                });
            }

            // Initialize player after shields are set
            let middleShield = shields[Math.floor(shields.length / 2)]; // Get the middle shield
            player = {
                x: middleShield.x + middleShield.width / 2 - playerWidth / 2, // Centered under the middle shield
                y: middleShield.y + shieldHeight + 40, // 30 pixels below shield level
                width: playerWidth,
                height: playerHeight,
                speed: 200,
                color: 'green',
                bullets: [],
                lives: 3,
                isExploding: false,
                explosionTimer: 0
            };
        }

        // Create shield segments as a grid
        function createShieldSegments(width, height) {
            let segments = [];
            const topRows = 2; // Top two rows
            const bottomRows = 3; // Bottom three rows
            const topCols = 2; // 2 columns for top rows
            const bottomCols = 4; // 4 columns for bottom rows

            const segmentWidth = width / bottomCols; // Base segment width for 4 columns
            const segmentHeight = height / (topRows + bottomRows); // Divide total height into 5 rows

            // Create top rows (2x2)
            for (let r = 0; r < topRows; r++) {
                for (let c = 0; c < topCols; c++) {
                    segments.push({
                        x: (bottomCols / 2 - topCols / 2) * segmentWidth + c * segmentWidth, // Centered 2 columns
                        y: r * segmentHeight,
                        width: segmentWidth,
                        height: segmentHeight,
                        intact: true,
                    });
                }
            }

            // Create bottom rows (4x3)
            for (let r = 0; r < bottomRows; r++) {
                for (let c = 0; c < bottomCols; c++) {
                    segments.push({
                        x: c * segmentWidth, // Spread across full width
                        y: topRows * segmentHeight + r * segmentHeight, // Offset below top rows
                        width: segmentWidth,
                        height: segmentHeight,
                        intact: true,
                    });
                }
            }

            return segments;
        }


        initEnemies(currentLevel);
        initShields();

        // Event Listeners

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.code === 'KeyB') {
                destroyAllAliens(); // Feature: Destroy all aliens
                return; // Prevent further processing
            }

            if (e.code === 'KeyM') { // **Handle 'M' Key**
                simulateMothershipHit(); // Function to simulate a mothership strike
            }
            if (e.code === 'Space') {
                if (!spacePressed) {
                    spacePressed = true;
                    if (gameState === 'start') {
                        startGame();
                        return;
                    }
                    if (gameState === 'playing' || gameState === 'paused') {
                        togglePause();
                        return;
                    }
                }
            }

            if (e.code === 'KeyP') {
                resetPlayer();
            }

            if (gameState === 'playing') {
                if (e.code === 'KeyH') {
                    toggleDirections();
                }
                if (e.code === 'Escape') {
                    endGame();
                }
            }

            // Track key state
            keys[e.code] = true;
        });
        // Start game on tap for mobile
        // Start game on tap for mobile
        if (isMobileDevice()) {
            startOverlay.addEventListener('touchstart', handleStart); // Attach listener to overlay
        }

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spacePressed = false;
            }
            keys[e.code] = false;
        
            // Reset fired flag for firing keys
            if (e.code === 'ControlLeft' || e.code === 'ControlRight') {
                keys['ControlFired'] = false;
            }
        });
function toggleDirections() {
    const directionsOverlay = document.getElementById('directionsOverlay');
    if (directionsOverlay.classList.contains('hidden')) {
        directionsOverlay.classList.remove('hidden');
        gameState = 'paused'; // Pause the game when help is shown
    } else {
        directionsOverlay.classList.add('hidden');
        gameState = 'playing'; // Resume the game when help is hidden
    }
}

        function startGame() {
            startOverlay.classList.add('hidden');
            gameState = 'playing';
            gameLoop();
        }

        function pauseGame() {
            gameState = 'paused';
        }

        function resumeGame() {
            gameState = 'playing';
            gameLoop();
        }

        function togglePause() {
            if (gameState === 'playing') {
                pauseGame();
            } else if (gameState === 'paused') {
                resumeGame();
            }
        }

        function endGame() {
            const confirmEnd = confirm('Are you sure you want to end the game?');
            if (confirmEnd) {
                gameState = 'gameover';
                showGameOver();
            }
        }

function showGameOver() {
    gameOverSound.play();
    gameState = 'gameover';

    // Apply grayscale filter if not already applied
    if (!canvas.style.filter.includes('grayscale')) {
        canvas.style.filter = 'grayscale(100%)';
    }

    // Update final score
    document.getElementById('finalScore').textContent = score;

    // Show the Game Over overlay
    document.getElementById('gameOverOverlay').classList.remove('hidden');
}
			// Optionally, you can add a "Restart" button or instructions here
    if (isMobileDevice()) {
        let touchStartX = 0;

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
        });

        canvas.addEventListener('touchmove', (e) => {
            const touchX = e.touches[0].clientX;
            const deltaX = touchX - touchStartX;

            // Move the player based on swipe direction
            if (deltaX > 10) {
                player.x += player.speed; // Move right
            } else if (deltaX < -10) {
                player.x -= player.speed; // Move left
            }

            touchStartX = touchX; // Update starting point
        });

        // Tap anywhere on the screen to fire
        canvas.addEventListener('touchend', () => {
            if (player.bullets.length < 3) {
                player.bullets.push({
                    x: player.x + player.width / 2 - 2.5,
                    y: player.y,
                    width: 5,
                    height: 15,
                    color: 'yellow'
                });
                fireSound.currentTime = 0;
                fireSound.play();
            }
        });
    }

        // Game Loop
function gameLoop() {
    const now = Date.now();
    const deltaTime = (now - lastUpdateTime) / 1000; // Time elapsed in seconds
    lastUpdateTime = now; // Update the time tracker

    if (gameState === 'playing') {
        update(deltaTime); // Always update game logic when playing
    }

    draw(); // Always draw the current state

    if (!gameOver) {
        requestAnimationFrame(gameLoop);
    }
}
        // Update Game State
function update(deltaTime) {
    if (gameState === 'gameover') {
        // No further updates needed
        return;
    }

    if (gameState === 'paused') {
        // Only update visual effects like explosions
        if (playerRespawning) {
            // Update explosions
            explosions.forEach((explosion, index) => {
                explosion.x += explosion.vx;
                explosion.y += explosion.vy;
                explosion.vx *= 0.98; // Apply friction
                explosion.vy *= 0.98;
                explosion.size *= 0.95; // Shrink explosion
                explosion.timer--;

                // Remove explosion particle if its timer expires or it becomes too small
                if (explosion.timer <= 0 || explosion.size < 0.5) {
                    explosions.splice(index, 1);
                }
            });

            // No further updates during pause
        }

        return; // Skip the rest of the update during pause
    }

    if (gameState === 'countdown') {
        const elapsed = Date.now() - countdownStartTime;

        // Transition to next level after countdown
        if (elapsed >= countdownDuration) {
            startNextLevel(); // Move to the next level
        }
        return; // Exit update to prevent further processing during countdown
    }

    if (gameState !== 'playing') return; // Skip updates if not playing

    // Handle player movement
    if (keys['ArrowLeft'] && player.x > 0) {
        player.x -= player.speed * deltaTime;
    }
    if (keys['ArrowRight'] && player.x + playerWidth < GAME_WIDTH) {
        player.x += player.speed * deltaTime;
    }

    // Fire player bullets
    if (
        (keys['ControlLeft'] || keys['ControlRight']) && // Fire button pressed
        !keys['ControlFired'] &&                        // Not already firing
        player.bullets.length < 3                       // Bullet count limit
    ) {
        player.bullets.push({
            x: player.x + player.width / 2 - 2.5,
            y: player.y,
            width: 5,
            height: 15,
            color: 'blue'
        });
        fireSound.currentTime = 0;
        fireSound.play();
        keys['ControlFired'] = true; // Prevent rapid fire
    }

    // Update player bullets
    player.bullets.forEach((bullet, index) => {
        bullet.y -= playerBulletSpeed * deltaTime * 60; // Scale speed appropriately

        // Remove bullet if it goes off-screen
        if (bullet.y + bullet.height < 0) {
            player.bullets.splice(index, 1);
        } else {
            let hit = false;

            // Check collision with enemies
            enemies.forEach((enemy, eIndex) => {
                if (enemy.alive && isColliding(bullet, enemy)) {
                    enemy.alive = false;
                    enemyHitSound.currentTime = 0;
                    enemyHitSound.play();
                    player.bullets.splice(index, 1);
                    score += 10;
                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                    adjustEnemySpeed();
                    hit = true;
                }
            });

            if (hit) return; // Bullet already handled

            // Check collision with shields
            shields.forEach((shield) => {
                shield.segments.forEach((segment) => {
                    if (segment.intact && isColliding(bullet, {
                        x: shield.x + segment.x,
                        y: shield.y + segment.y,
                        width: segment.width,
                        height: segment.height
                    })) {
                        segment.intact = false;
                        player.bullets.splice(index, 1);
                        hit = true;
                    }
                });
            });

            if (hit) return; // Bullet already handled

            // Check collision with motherships
            motherships.forEach((mothership, mIndex) => {
                if (mothership.alive && isColliding(bullet, mothership)) {
                    let points = mothership.points;

                    if (mothership.type === 'fast') {
                        player.lives += 1; // Grant an extra life
                        console.log('Fast mothership destroyed! Player gains an extra life.');
                    } else {
                        console.log('Slow mothership destroyed! Awarded 50 points.');
                    }

                    score += points;
                    destroyMothership(mothership);
                    player.bullets.splice(index, 1);
                    createExplosion(mothership.x + mothership.width / 2, mothership.y + mothership.height / 2);
                    hit = true;
                }
            });
        }
    });

    // Calculate and adjust enemy speed
    enemySpeed = calculateEnemySpeed();

    // Move enemies in 'step' fashion
    const now = Date.now();
    if (now - lastStepTime > stepDelay) {
        let shouldMoveDown = false;

        enemies.forEach(enemy => {
            if (enemy.alive) {
                enemy.x += enemySpeed * (enemyWidth / 2) * enemyDirection;) // Half-step horizontal movement
                enemy.frame = 1 - enemy.frame; // Toggle frame for animation

                if (enemy.x + enemy.width >= GAME_WIDTH - enemyPadding || enemy.x <= enemyPadding) {
                    shouldMoveDown = true;
                }
            }
        });

        if (shouldMoveDown) {
            enemyDirection *= -1;
            enemies.forEach(enemy => {
                if (enemy.alive) {
                    enemy.y += enemyHeight / 2; // Half-step vertical movement
                }
            });
        }

        // Play step sound and cycle
        invaderSounds[currentInvaderSound].currentTime = 0;
        invaderSounds[currentInvaderSound].play();
        currentInvaderSound = (currentInvaderSound + 1) % invaderSounds.length;

        lastStepTime = now;
        adjustEnemySpeed(); // Update speed based on enemies
    }

    // Check collision between enemies and shields
    enemies.forEach(enemy => {
        if (enemy.alive) {
            shields.forEach(shield => {
                shield.segments.forEach(segment => {
                    if (segment.intact && isColliding(enemy, {
                        x: shield.x + segment.x,
                        y: shield.y + segment.y,
                        width: segment.width,
                        height: segment.height
                    })) {
                        segment.intact = false;
                    }
                });
            });
        }
    });

    // Fire enemy bullets
    if (!enemyFiringDisabled && Math.random() < 0.005) { // Adjusted firing frequency
        const aliveEnemies = enemies.filter(e => e.alive);
        if (aliveEnemies.length > 0) {
            const shooter = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
            enemyBullets.push({
                x: shooter.x + shooter.width / 2 - bulletWidth / 2,
                y: shooter.y + shooter.height,
                width: bulletWidth,
                height: bulletHeight,
                color: 'red'
            });
        }
    }

    // Update enemy bullets
    enemyBullets.forEach((bullet, index) => {
        bullet.y += bulletSpeed * deltaTime * 60; // Scale speed appropriately

        // Remove bullet if it goes off-screen
        if (bullet.y > GAME_HEIGHT) {
            enemyBullets.splice(index, 1);
        } else {
            let hit = false;

            // Check collision with shields
            shields.forEach((shield) => {
                shield.segments.forEach((segment) => {
                    if (segment.intact && isColliding(bullet, {
                        x: shield.x + segment.x,
                        y: shield.y + segment.y,
                        width: segment.width,
                        height: segment.height
                    })) {
                        segment.intact = false;
                        enemyBullets.splice(index, 1);
                        hit = true;
                    }
                });
            });

            if (hit) return; // Bullet already handled

            // Check collision with player
            if (isColliding(bullet, player) && !player.isExploding) {
                enemyBullets.splice(index, 1);
                playerHitSound.currentTime = 0;
                playerHitSound.play();
                createExplosion(player.x + player.width / 2, player.y + player.height / 2);
                 
                if (player.lives > 0) {
                    resetPlayer();
                } else {
                    gameOver = true;
                    showGameOver();
                }
            }
        }
    });

    // Update motherships
    motherships.forEach((mothership, mIndex) => {
        if (mothership.alive) {
            mothership.x += mothership.speed;

            // Stop sound and remove mothership if it leaves the screen
            if ((mothership.direction === 'right' && mothership.x > GAME_WIDTH) ||
                (mothership.direction === 'left' && mothership.x + mothership.width < 0)) {
                mothership.alive = false;
                mothership.sound.pause();
                mothership.sound.currentTime = 0; // Reset sound
                isMothershipSoundPlaying = false;
            }
        }
    });

    // Remove dead motherships and stop their sounds
    motherships = motherships.filter(mothership => {
        if (!mothership.alive) {
            mothership.sound.pause();
            mothership.sound.currentTime = 0;
            return false; // Remove from array
        }
        return true;
    });

    // Spawn Motherships
    if (Date.now() - lastMothershipTime > mothershipInterval) {
        spawnMothership();
        lastMothershipTime = Date.now();
    }

    // Update Explosions
    explosions.forEach((explosion, index) => {
        explosion.x += explosion.vx; // Move horizontally
        explosion.y += explosion.vy; // Move vertically

        // Apply slight slowdown effect (friction)
        explosion.vx *= 0.98;
        explosion.vy *= 0.98;

        // Gradually shrink particle size
        explosion.size *= 0.95;

        // Reduce timer
        explosion.timer--;

        // Remove particles when their timer expires or they become too small
        if (explosion.timer <= 0 || explosion.size < 0.5) {
            explosions.splice(index, 1);
        }
    });

    // Update Fireworks
    fireworks.forEach((firework, index) => {
        firework.timer--;
        firework.particles.forEach((particle) => {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.vy += particle.gravity;
        });
        if (firework.timer <= 0) {
            fireworks.splice(index, 1);
        }
    });

    // Check Win Condition
    if (enemies.every(e => !e.alive)) {
        createFireworks();
        gameState = 'countdown';
        countdownStartTime = Date.now();
    }

    // Check if any enemy has reached the player's level
    enemies.forEach(enemy => {
        if (enemy.alive && enemy.y + enemy.height >= player.y) {
            gameOver = true;
            showGameOver();
        }
    });
}

    function adjustStepSpeed() {
        const remainingEnemies = enemies.filter(enemy => enemy.alive).length;
        const totalEnemies = enemyRows * enemyCols;

        if (remainingEnemies === 1) {
            stepDelay = 200 / 3; // 200% faster for the last enemy
        } else if (remainingEnemies <= totalEnemies / 4) {
            stepDelay = 300 * 0.8; // Speed 3 increased by 20%
        } else if (remainingEnemies <= totalEnemies / 2) {
            stepDelay = 500; // Speed 2 unchanged
        } else if (remainingEnemies <= (3 * totalEnemies) / 4) {
            stepDelay = 650; // Speed 1 unchanged
        } else {
            stepDelay = 800; // Starting speed
        }
    }

    function drawEnemies() {
        enemies.forEach(enemy => {
            if (enemy.alive) {
                const img = alienImages[enemy.type][enemy.frame]; // Select image by type and frame
                
                // Ensure the image is loaded before drawing
                if (img.complete && img.naturalHeight !== 0) {
                    ctx.drawImage(img, enemy.x, enemy.y, enemy.width, enemy.height); // Draw alien image
                } else {
                    // Fallback placeholder if image is not loaded
                    ctx.fillStyle = 'white';
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                }
            }
        });
    }
function drawExplosions() {
    explosions.forEach(explosion => {
        ctx.fillStyle = explosion.color; // Random color per particle
        ctx.beginPath();
        ctx.arc(explosion.x, explosion.y, explosion.size, 0, Math.PI * 2);
        ctx.fill();
    });
}
            
            
    function drawMotherships() {
        motherships.forEach(mothership => {
            if (mothership.alive) {
                if (mothershipImage.complete && mothershipImage.naturalHeight !== 0) {
                    // Draw mothership using the image
                    ctx.drawImage(mothershipImage, mothership.x, mothership.y, mothership.width, mothership.height);
                } else {
                    // Fallback placeholder if image isn't loaded
                    ctx.fillStyle = 'purple';
                    ctx.fillRect(mothership.x, mothership.y, mothership.width, mothership.height);
                }
            }
        });
    }

function drawPlayer() {
    if (!player.isExploding) {
        if (playerImage.complete && playerImage.naturalHeight !== 0) {
            ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
        } else {
            // Fallback placeholder if the image hasn't loaded
            ctx.fillStyle = 'green';
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }
    }
}



    function drawShields() {
        shields.forEach(shield => {
            shield.segments.forEach(segment => {
                if (segment.intact) {
                    // Draw the shield segment using the shieldImage
                    if (shieldImage.complete && shieldImage.naturalHeight !== 0) {
                        ctx.drawImage(
                            shieldImage, // Source image
                            shield.x + segment.x, // X position
                            shield.y + segment.y, // Y position
                            segment.width, // Width
                            segment.height // Height
                        );
                    } else {
                        // Fallback if image isn't loaded
                        ctx.fillStyle = 'green';
                        ctx.fillRect(shield.x + segment.x, shield.y + segment.y, segment.width, segment.height);
                    }
                }
                // **Remove the else block to prevent clearing shield segments programmatically**
                // Else: Do not draw anything, allowing invaders to pass through
            });
        });
    }
    function drawFireworks() {
        fireworks.forEach(firework => {
            firework.particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
        });
    }

        // Draw Game State
function draw() {
    // Clear Canvas
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    if (gameState === 'start') {
        // Draw start overlay
        return;
    }

    if (gameState === 'gameover') {
        // Game Over overlay is handled separately
        return;
    }

    // Draw game elements
    if (gameState === 'playing' || gameState === 'paused') {
        // Draw Player
        drawPlayer();

        // Draw Player Bullets
        player.bullets.forEach(bullet => {
            ctx.fillStyle = bullet.color;
            ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        });

        // Draw Enemies
        drawEnemies();

        // Draw Enemy Bullets
        enemyBullets.forEach(bullet => {
            ctx.fillStyle = bullet.color;
            ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        });

        // Draw Shields
        drawShields();

        // Draw Motherships
        drawMotherships();

        // Draw Explosions
        drawExplosions();

        // Draw Fireworks
        drawFireworks();

        // Draw Score and Lives
        const padding = 20; // Space from the edges
        const textHeight = 30; // Height for text placement
        const retroColor = '#00FF00'; // Classic arcade green color

        ctx.fillStyle = retroColor;
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'left';
        ctx.fillText(`SCORE: ${score}`, padding, textHeight);

        // Draw Player Lives (Top Right)
        ctx.textAlign = 'right';
        ctx.fillText(`LIVES: ${player.lives}/3`, GAME_WIDTH - padding, textHeight);
        ctx.textAlign = 'left';

        // If the game is paused, draw the pause overlay
        if (gameState === 'paused') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(GAME_WIDTH / 2 - 150, GAME_HEIGHT / 2 - 75, 300, 150);
            ctx.fillStyle = 'white';
            ctx.font = isMobileDevice() ? '24px Arial' : '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Paused', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20);
            ctx.fillText('Press Spacebar to Resume', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 20);
            ctx.textAlign = 'left';
        }
    }
}



        // Collision Detection
        function isColliding(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

    // Create Scatter Explosion Effect
    function createExplosion(x, y) {
        const particleCount = 50; // Increase particle count for a larger scatter
        const explosionSpeed = 4; // Increase speed for more spread
        const explosionSize = 5; // Larger initial size for particles

        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2; // Random angle (0 to 360 degrees)
            const speed = Math.random() * explosionSpeed + 1; // Random speed between 1 and explosionSpeed
            explosions.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed, // Horizontal velocity
                vy: Math.sin(angle) * speed, // Vertical velocity
                size: Math.random() * explosionSize + 2, // Random size between 2 and explosionSize
                color: `hsl(${Math.random() * 360}, 100%, 50%)`, // Random colors for vibrant effect
                timer: Math.random() * 40 + 30 // Lifespan between 30 and 70 frames
            });
        }

        explosionSound.currentTime = 0;
        explosionSound.play();
    }


        // Reset Player After Hit
 
function resetPlayer() {
    if (playerRespawning || player.isExploding) {
        console.log('Player is already respawning or exploding.');
        return;
    }

    console.log('Player hit! Starting respawn sequence.');
    player.isExploding = true;
    playerRespawning = true;

    // Decrement lives
    if (player.lives > 0) {
        player.lives--;
        console.log(`Lives decremented: ${player.lives}`);
    }

    // Trigger explosion
    createExplosion(player.x + player.width / 2, player.y + player.height / 2);
    explosionSound.currentTime = 0;
    explosionSound.play();

    // Disable enemy firing and clear existing enemy bullets
    enemyFiringDisabled = true;
    enemyBullets = [];

    // Define durations
    const explosionDuration = 1200; // 1.2 seconds for explosion animation
    const grayscaleDuration = 1000; // 1 second for grayscale effect
    const pauseDuration = 3000;      // 3 seconds pause before next level

    // Sequence the events using nested setTimeouts
    setTimeout(() => {
        console.log('Applying grayscale filter.');
        canvas.style.filter = 'grayscale(100%)'; // Apply grayscale

        setTimeout(() => {
            console.log('Pausing game before next level.');

            // Pause the game by setting gameState to 'paused'
            gameState = 'paused';

            setTimeout(() => {
                console.log('Resuming game and starting next level.');

                // Remove grayscale filter
                canvas.style.filter = 'none';

                // Reset player position
                player.x = GAME_WIDTH / 2 - playerWidth / 2;
                player.y = GAME_HEIGHT - playerHeight - 40;

                // Remove respawning flags
                player.isExploding = false;
                playerRespawning = false;

                // Re-enable enemy firing
                enemyFiringDisabled = false;

                // Start the next level
                startNextLevel();

            }, pauseDuration); // Wait before starting next level

        }, grayscaleDuration); // Wait for grayscale to apply

    }, explosionDuration); // Wait for explosion to complete
}



        // Calculate Enemy Speed Based on the Number of Remaining Enemies
    // Calculate Enemy Speed Based on the Number of Remaining Enemies
    function calculateEnemySpeed() {
        const remainingEnemies = enemies.filter(enemy => enemy.alive).length;
        if (remainingEnemies === 0) return 1; // Default speed when no enemies

        // Calculate speed based on remaining enemies
        // When remainingEnemies = initialEnemyCount => speed = 1
        // When remainingEnemies = 1 => speed = 8
        let speed = 1 + (7 * (initialEnemyCount - remainingEnemies)) / (initialEnemyCount - 1);
        speed = Math.min(speed, 8); // Ensure speed does not exceed 8
        return speed;
    }

        // Adjust Enemy Speed Based on the Number of Remaining Enemies
        function adjustEnemySpeed() {
            enemySpeed = calculateEnemySpeed();
        }

        // Spawn Mothership
function spawnMothership() {
    // Check if a mothership is already active
    if (motherships.some(mothership => mothership.alive)) {
        console.log('Mothership already active. Not spawning a new one.');
        return;
    }

    const direction = Math.random() < 0.5 ? 'right' : 'left';
    const isFast = Math.random() < 0.2; // 20% chance for fast
    const selectedType = isFast ? MOTHERSHIP_TYPES.FAST : MOTHERSHIP_TYPES.SLOW;

    // Select the appropriate preloaded sound
    const selectedSound = isFast ? mothershipFastSound : mothershipSlowSound;

    const mothership = {
        x: direction === 'right' ? -80 : GAME_WIDTH,
        y: 30,
        width: 80,
        height: 20,
        speed: selectedType.speed * (direction === 'right' ? 1 : -1),
        direction: direction,
        alive: true,
        type: selectedType.type,
        points: selectedType.points,
        sound: selectedSound, // Assign the preloaded sound
    };

    // Play mothership sound
    mothership.sound.currentTime = 0; // Reset to start in case it's reused
    mothership.sound.play();

    // Add the mothership to the array
    motherships.push(mothership);
    console.log(`Spawned a ${selectedType.type} mothership moving ${direction}.`);
}

        // Start Next Level
function startNextLevel() {
    currentLevel++; 
    stepDelay = 800; // Reset step delay to starting value
    initEnemies(currentLevel); 
    resetShields(); 
    fireworks = []; 
    adjustStepSpeed(); 
    gameState = 'playing'; 
    gameLoop(); // Start the game loop for the next level
}


        // Reset Shields to full integrity
        function resetShields() {
            shields.forEach(shield => {
                shield.segments.forEach(segment => {
                    segment.intact = true;
                });
            });
        }

        // Initialize Game Loop and Draw Loop
        gameLoop();
    </script>
<a href="https://linktr.ee/tomwellborn3" target="_blank" 
   style="position: absolute; bottom: 10px; left: 10px; color: gray; font-size: 12px; text-decoration: none;">
   Tom Wellborn, 2025, <br>Version 1.5 Alpha
</a>
</body>
</html>
